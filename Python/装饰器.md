==谈装饰器前，要先要明白一件事，Python 中的函数和 Java、C++不太一样，Python 中的函数可以像普通变量一样当做参数传递给另外一个函数==

你定义了一个Ball类别，你可以建立实例并直接存取radius特性。如果这个对象在别处使用，你必须打开原有的实现这个类的源代码，修改源代码来实现。
事实上在Python中，你可以直接使用Property（）函数来修改类。

比如我写了一个判断某个区间的素数的个数的函数，然后我想测试这个函数运行需要多长时间，那我就需要在原来的基础上修改函数内部的代码，而装饰器可以让我们不修改函数内部代码的功能，就能实现测试函数的运行时间。

**装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。**
>概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。
>它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。

## 背景分析
先来看一个简单例子，虽然实际代码可能比这复杂很多：
```py
def is_prime(num):
    if num<2:
        return False
    elif num==2:
        return True
    else:
        for i in range(2,num):
            if num %i==0:
                return False

        return True
def prime_nums():
    for i in range(2,1000):
        if is_prime(i):
            print(i)
```
现在有一个新的需求，计算上述函数的运行时间，笨办法修改内部代码,可读性差，逻辑性不好，应该把逻辑和计时分开。

```py
def prime_nums():
    t1 = time.time()
    for i in range(2,1000):
        if is_prime(i):
            print(i)
    t2 = time.time()
    print(t1-t2)
```
我们可以定义一个装饰器，display_time()函数
```py
def display_time(func):
    def wrapper():
        t1= time.time()
        func()
        t2= time.time()
        print(t2-t1)
    return wrapper
```
想把上述的装饰器函数应用在某个函数A上的话，直接在A函数上方定义一行代码`@display_time`，如果说某个地方调用A，那么首先就会执行函数上部装饰器的内容，运行wrapper内容。

## 语法糖
如果你接触 Python 有一段时间了的话，想必你对 @ 符号一定不陌生了，没错 @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。
```python
def use_logging(func):
    def wrapper():
        logging.warn("%s is running" % func.__name__)
        return func()
    return wrapper

@use_logging
def foo():
    print("i am foo")

>>> foo()
```
如上所示，有了 @ ，我们就可以省去`foo = use_logging(foo)`这一句了，直接调用 foo() 即可得到想要的结果。你们看到了没有，foo() 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样
>装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。

## 有返回值的业务逻辑
直接把返回值在wrapper函数中返回出来即可
## 需要参数（\*args，\**kwargs）的业务逻辑函数
定义wrapper函数的时候，定义一个\*args，使其接收被装饰函数需要传递的参数
==args是一个数组，kwargs一个字典.==

可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？比如：
```python
def foo(name):
    print("i am %s" % name)
```
我们可以在定义 wrapper 函数的时候指定参数：
```python
def wrapper(name):
        logging.warn("%s is running" % func.__name__)
        return func(name)
    return wrapper
```
这样 foo 函数定义的参数就可以定义在 wrapper 函数中。这时，又有人要问了，如果 foo 函数接收两个参数呢？三个参数呢？更有甚者，我可能传很多个。当装饰器不知道 foo 到底有多少个参数时，我们可以用 \*args 来代替：
```python
def wrapper(*args):
        logging.warn("%s is running" % func.__name__)
        return func(*args)
    return wrapper
```
如此一来，甭管 foo 定义了多少个参数，我都可以完整地传递到 func 中去。这样就不影响 foo 的业务逻辑了。这时还有读者会问，如果 foo 函数还定义了一些关键字参数呢？比如：
```python
def foo(name, age=None, height=None):
    print("I am %s, age %s, height %s" % (name, age, height))
```
这时，你就可以把 wrapper 函数指定关键字函数：
```python
def wrapper(*args, **kwargs):
        # args是一个数组，kwargs一个字典
        logging.warn("%s is running" % func.__name__)
        return func(*args, **kwargs)
    return wrapper
```
## 装饰器的类别
- 类装饰器
相比函数装饰器，类装饰器具有灵活度大，高内聚，封装性等优点。使用类装饰器主要依靠类的__call__方法，当使用@形式将装饰器附加到函数上时，就会调用此方法。
- 函数装饰器
使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的原信息不见了
## 装饰器顺序
一个函数还可以同时定义多个装饰器，比如：
```
@a
@b
@c
def f():
	pass
```
它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于：
`f = a(b(c(f)))`
## @property函式
- 对于非公有变量（变量名前加_），修改其变量的值，需要成员函数来进行，比如setter等。
- 一个函数foo用@property修饰之后，类非公有变量相对于foo函数，全部都为共有变量了。
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTYxMTI2MTE1NF19
-->
