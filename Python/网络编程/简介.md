## 应用层网络编程：
request对象，输入参数指定的比较全，URL层面的操作。

- 应用层的编程构建了一个URL，并获取了URL查询的响应文档。这一操作听上去相当简单，但是web浏览器其实做了很多的工作。然而，URL之所以可以用来获取某个文档，真正原因显然是描述了网络上该特定文档的位置以及获取方法。URL包含了：协议名，主机名，文档路径。

==这一层只能使用HTTP协议。==
## 协议层的使用

- 如果不想使用Request库提供的神奇功能，而是想直接使用HTTP来获取结果，就可以使用协议的层面来操作。

- python中例如http.client模块。
这时提供的参数就少了协议名，参数有：主机名，获取的方法

流程
- 先请求连接主机。
- 手动构造带path参数的GET查询。
 - 最后直接从HTTP连接读取响应结果。

HTTP只是Python标准库提供内置实现的众多协议之一。
比前一个来说，在协议栈中更低了一层。
==这个层协议是可以选择的，是在协议的基础上进行的。==
## 最底层的socket层
HTTP是无法通过稀薄的空气在两台机器之间传输数据的。HTTP协议必须使用一些更简单的抽象来完成操作。

==可以在socket上层构建很多的协议，也可以自定义协议。==

事实上，现代操作系统提供了使用TCP协议在IP网络的不同间进行纯文本网络会话的功能。HTTP协议精确描述了两台主机间通过TCP传输信息的格式。

socket已经深入了最底层：使用主机操作系统提供的原始socket函数来支持IP网络上的网络通信。

输入参数：主机，端口，和要传送的字符。

## 总结
协议栈包含四层：
- 最上层的应用层
- URL，标识了可通过HTTP获取的文档，比如浏览器。
- HTTP层，支持面向文档的命令。该层的操作使用了原始的TCP/IP套接字。
- TCP/IP套接字，只处理字符串的发送和接受。


可以看到，协议栈的每一层都使用了其底层协议提供的功能，并同时向上层协议提供服务。




> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4MzA0ODYyMSwtMjc3NTM1MDU3LDcxMD
c0NDI3Nl19
-->