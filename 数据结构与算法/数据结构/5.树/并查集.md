## 概念
并查集通过一个一维数组来实现，其本质是维护一个森林。
刚开始的时候。森林的每个点都是孤立的，也可以理解为每个点就是一棵只有一个节点的树，之后通过一些条件，逐渐将这些树合并为一棵大树

其实合并的过程就是“认爹”的过程，要遵守“靠左”原则和擒贼先擒王的原则。在每次判断两个结点是否已经在同一棵树中的时候（一棵树其实就是一个集合），也要注意必须求其根源，中间父节点是不能说明问题的，必须找到其祖宗（树的根结点），判断两个结点的祖宗是否是同一个根结点才行。

比如犯罪团伙的解密，有很关联的线索，需要查出多少个独立的犯罪团伙问题！
## 代码
并查集寻找祖先的函数
```c
int getf(int v)
{
  if(f[v]==v)
    return v;
  else
  {
    //路径压缩
    f[v] = getf(f[v])
    return f[v];
  }
}
```
并查集合并两个子集的函数
```c
int merge(int v,int u)
{
  int t1,t2;
  t1 = gegf(v);
  t2 = getf(u);
  if(t1!=t2)
  {
    f[t2] = t1;
    return 1;
  }
  return 0;
}
```
并查集初始化
```c
for(i=1:i<=n;i++)
{
  f[i] = i;
}
```
## 应用
判断一个图中是否形成一个环
- 不断的选择边，然后将边的顶点加入到一个集合当中。
- 如果再选择一条边在同一个集合里面，那就存在一个环。

关键：怎么合并集合
