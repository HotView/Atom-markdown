## 背景
优先队列：特殊的“队列”，取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序
#### 定义
==支持插入元素和寻找最大最小值元素的数据结构成为优先队列==

==数组或链表实现优先队列==
数组：插入1，删除n
链表：插入1，删除n
有序数组：插入n，log(n)
以上的效果都不是很满意。

**是否可以采用二叉树存储结构？**
二叉搜索树：多次操作，树就变形了。

重点考虑删除最大值。
数据放在二叉树中，最大的放在树根。
就是堆的定义，完全二叉树！

==完全二叉树可以通过数组来实现，可以在数组中很方方便的存取一个完全二叉树。==

## 堆（heap）的定义
- 堆是一种特殊的完全二叉树
- heap中存储的值是偏序
符合这样特点的完全二叉树我们成为二叉最小堆。
- 最小堆：父节点的值小于等于子节点的值
- 最大堆：父节点的值大于等于子节点的值


堆的定义和构造：
- 对于n条记录组成的序列${k_1，k_2,.....,k_n}$
$K_i<=K_{2i}$
$K_i<=K_{2i+1}$
或者
$K_i>=K_{2i}$
$K_i>=K_{2i+1}$
- 若将此序列对应的一位数组看做是一颗完全二叉树，则堆的定义表明，完全二叉树中所有非叶子节点的值均不大于（或不小于）其左右子结点值。
## 堆的存储
一般都用数组来表示堆，i结点的父结点下标就为(i–1)/2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2
##堆的操作
- 插入操作
每次插入元素都是将其放在数组的最后，可以发现从这个新数据的父节点到根节点必然为为一个有序数列，现在是怎样将这个数据结构变为有序的状态。
- 删除操作
按照定义，堆中每次都删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋值给根节点，然后再从根节点进行一次从上向下的调整，调整时，先在左右儿子节点中找最大的，如果父节点比这个最小的子节点还大，就说明不需要调整了；反之将父结点和它交换后再考虑后面的结点。









> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc3OTA4Njk1Nl19
-->
