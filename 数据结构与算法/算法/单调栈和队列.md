两个特殊的数据结构存储的都是数据的索引下标。
## 单调队列
特殊的数据结构，需要使用deque，队头和队尾都需要插入和删除操作。一般一个算法的优化步骤
- 暴力枚举：n*n
- 堆平衡树优化，nlogn
- 单调队列：n

#### 求区间最大值
维护一个滑动窗口的最大值，那么将最大值放在队头，然后从队头插入元素。判断队尾是否在窗口之内，如果不在，删除队尾。
- 声明两个指针滑动，i遍历每个元素，j表示判断元素的最晚的那一个元素的下标。
- 先让元素入队，如果队头元素小于它，就将队头元素出队头
- 入队头
- 判断窗口是否大于k，如果窗口大于k，那么将队尾元素出队。
- 判断是否等于k，如果等于看，那么就将队头元素指向的元素保存到结果中去。
##单调栈
每次都要将新元素入栈，要保证栈内是有序的，所以在入栈之前，要进行判断出栈操作，一般栈顶到栈底单调递增的序列。

先将要求的数组使用单调栈遍历一遍，然后用字典来保存其右边的第一大于或者小于它的数字的索引即可。
- 如果是右边的话就是逆序遍历
- 如果是左边的话就是正序遍历

## 模板
####单调栈 —— 模板题 AcWing 830. 单调栈
常见模型：找出每个数左边离它最近的比它大/小的数
```c
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(q[tt], i)) tt -- ;//判断栈顶
    stk[ ++ tt] = i;
}
```
####单调队列 —— 模板题 AcWing 154. 滑动窗口
常见模型：找出滑动窗口中的最大值/最小值
```c
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;//判断队尾
    q[ ++ tt] = i;
}
```
