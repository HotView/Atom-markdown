插入排序直接在一个已排好序的记录子集基础上，每一步将下一个待排序的记录有序的插入到已排序好的记录子集中去。
- 直接插入排序
- 二分插入排序
- 希尔排序
## 直接插入排序
两个序列空间，一个是排序结果的序列B，另一个是原序列A。
取A中的一个元素i，然后放入B中，但是B中的元素是有序的，所以需要将i与B中的元素一一作比较（从头到尾），插入到合适的位置中去

#### 算法描述
- 从第一个元素开始，可以认为该元素已经被排序
- 取出下一个元素，在已经排序的元素序列中从后向前扫描
- 如果该元素（已排序）大于新元素，将该元素移到下一位置。
- 重复步骤三，直到找到已排序的元素小于或者等于新元素的位置。
- 将新元素插入到该位置中。
#### 实现
- 类似于打扑克牌
不断的拿到新牌，然后将新牌与现有的序列比较，插入到合适的位置中。

```c
void Insertion_Sort(ElementType A[],int N)
{
	for (p= 1;p<N;p++)/*第一张牌已经在手里了*/
	{
		tmp = A[p];/*摸第一张牌*/
		for(i =p;i>0 && A[i-1]>tmp;i--)
		{
			A[i] = A[i-1];
		}
		A[i] = tmp;
	}
}

```
相当于从一个栈中，移到另一个栈中，来排序。
##希尔排序
背景
利用了插入排序的简单，同时克服了插入排序每次只交换相邻两个元素的缺点。
最坏是O(N*N)
#### 定义一个增量序列
序列是递减的，也就是$Dm>D{m-1}...D1=1$。
对每个Dk进行Dk间隔排序。
例子
- 每次除以2.
#### 取间隔$D_k$
每隔5个元素来选取一个比较集合。
然后用插入排序对选取的集合进行排序。
#### 变小间隔$D_{k-1}$
重复上述步骤
#### 代码
在插入排序的外层，再套一个for循环。
```c
void Insertion_Sort(ElementType A[],int N)
{
for(D = N/2;D>0;D/=2)
{
	for (p= D;p<N;p++)/*第一张牌已经在手里了*/
	{
		tmp = A[p];/*摸第一张牌*/
		for(i =p;i>0 && A[i-1]>tmp;i--)
		{
			A[i] = A[i-1];
		}
		A[i] = tmp;
	}
}

}

```
