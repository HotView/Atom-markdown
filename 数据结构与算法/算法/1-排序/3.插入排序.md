- 直接插入排序
- 二分插入排序
- 希尔排序
## 直接插入排序
两个序列空间，一个是排序结果的序列B，另一个是原序列A。
取A中的一个元素i，然后放入B中，但是B中的元素是有序的，所以需要将i与B中的元素一一作比较（从头到尾），插入到合适的位置中去
#### 实现
- 类似于打扑克牌
不断的拿到新牌，然后将新牌与现有的序列比较，插入到合适的位置中。

```c
void Insertion_Sort(ElementType A[],int N)
{
	for (p= 1;p<N;p++)/*第一张牌已经在手里了*/
	{
		tmp = A[p];/*摸第一张牌*/
		for(i =p;i>0 && A[i-1]>tmp;i--)
		{
			A[i] = A[i-1];
		}
		A[i] = tmp;
	}
}

```
相当于从一个栈中，移到另一个栈中，来排序。
##希尔排序
背景
利用了插入排序的简单，同时克服了插入排序每次只交换相邻两个元素的缺点。
最坏是O(N*N)
#### 定义一个增量序列
序列是递减的，也就是$Dm>D{m-1}...D1=1$。
对每个Dk进行Dk间隔排序。
例子
- 每次除以2.
#### 取间隔$D_k$
每隔5个元素来选取一个比较集合。
然后用插入排序对选取的集合进行排序。
#### 变小间隔$D_{k-1}$
重复上述步骤
#### 代码
在插入排序的外层，再套一个for循环。
```c
void Insertion_Sort(ElementType A[],int N)
{
for(D = N/2;D>0;D/=2)
{
	for (p= D;p<N;p++)/*第一张牌已经在手里了*/
	{
		tmp = A[p];/*摸第一张牌*/
		for(i =p;i>0 && A[i-1]>tmp;i--)
		{
			A[i] = A[i-1];
		}
		A[i] = tmp;
	}
}

}

```
