时间复杂度为==O($N^2$)==
## 冒泡排序
每一次可以确定一件事，就是将现有的排序队列中的最大元素，移动到最底端。
####  特点
调整相邻两个对象的位置，每进行一次内循环，就可以将最大值调整到最后，这样以后就不必再考虑它了。
在进行n-1次内循环后，就得到完整的有序列。
时间复杂度是O($n^2$)
没有时间优势，但是代码简介，难度低。
```python
for i in (1,2,3,...,n-1):
	for j in (1,2,..,n-i):
		if aj>aj+1:
			交换aj和aj+1
		end if
	end for
end for
```
## 插入排序
- 类似于打扑克牌
不断的拿到新牌，然后将新牌与现有的序列比较，插入到合适的位置中。

```c
void Insertion_Sort(ElementType A[],int N)
{
	for (p= 1;p<N;p++)/*第一张牌已经在手里了*/
	{
		tmp = A[p];/*摸第一张牌*/
		for(i =p;i>0 && A[i-1]>tmp;i--)
		{
			A[i] = A[i-1];
		}
		A[i] = tmp;
	}
}

```
相当于从一个栈中，移到另一个栈中，来排序。
## 选择排序
先找到位置不合适的元素，再把它放在其最终合适的位置，很明确的交换数组元素。
#### 基本思想
先找出数组中最小的元素，将其余第一个位置上的元素做交换。然后在剩余的元素中继续寻找最小的元素，然后让其与第二个元素做交换，以此类推即可！分而治之




> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgwODM3Njg4NSwtMTQ0NjMzNTgwNywxOT
Y0OTIzMjQ2XX0=
-->