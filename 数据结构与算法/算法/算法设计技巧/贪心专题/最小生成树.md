## Kruskal算法
对象是边，适合稀疏图。

我们首先想到的是选择最短的边，然后选择次短的边，直到选择了n-1条边为止。这就需要对所有的边按照权值排序。选择n-1条边让整个图连通为止。
- 依次选择比较短的且边的两个顶点不在同一个集合内的边（不产生回路），如果加入的边构成回路的话，我们就需要将这条边跳过，测试下一条边，直到加入了n-1条边为止。
- 难点就是判断两个顶点是否已经连通，但是我们可以使用并查集来判断两个顶点是否连通，只需判断两个顶点是否在同一个集合即可。


```c
//merge函数在并查集有声明
struct edge
{
	int u;
	int v;
	int w;
};
struct edge e[10];
//先按权值排序，此处省略。
for(i=1;i<=m;i++)
{
	if( merge(e[i].u,e[i].v) )
	{
		count++;
		sum = sum+e[i].w;
	}
	if(count ==n-1)
		break;
}
```

## prim算法
对象是结点，适合稠密图。
有点像Dijkstra算法。

要用n-1条边将n个顶点连接起来，那么每个顶点都必须至少有一条与它相连。
- 那我随便选一个点A开始，看看这个顶点有哪些边，在它的边中选取一最小的边：A-B。
- 连接AB之后，剩下的顶点怎么办呢？一定要向这两个顶点靠近才可以，越近越好。于是我们可以枚举A，B两个顶点的所有边，看看哪些边可以连接到没有选中的顶点，并且边越短越好。
- 依次重复此操作，重复n-1次，直到所有顶点都选中 ，算法结束。

总结一下
- 所有顶点分为两类，树顶点和非树顶点，使用book数组0,1来表示，1表示顶点加入生成树。
- 用数组dis来记录生成树到各个顶点的距离，是每一个顶点到树顶点的最短距离。
- 每次加入新增一个树顶点时，都要更新dis数组
- ==定义一个parent，存储生成树==。`parent【W】 = V`
```c
void prim()
{
	while(count<n)
	{
		min =inf;
		for(i=1;i<=n;i++)
		{
			if(book[i]==0&& dis[i]<min)
			{
				min = dis[i];
				j=i;
			}
			book[j]=1;
			count++;
			sum = sum+dis[j]
			//扫描当前顶点j的所有边，再以j为中间点，更新生成树到每一个非树顶点的距离
			for(k=1;k<=n;k++)
			{
				if(book[k]==0&&dis[k]>e[j][k])
					dis[k] = e[j][k]
			}
		}
	}
}
```
