在编码过程中，如果按照统一的子长进行编码，则对于一些元素概率不均匀的情况下，空间浪费很严重。
所以有人提出了通过概率的不同，来进行不同的编码方式
- 对于概率较大的，编码的子长尽可能短，概率较小的，编码的子长可以长些
## 霍夫曼编码
是一种可变子长编码，如果码字长度严格按照对应符号出现的概率大小逆序排列，则其平 均码字长度为最小。
基本思想：
>赫夫曼编码的具体方法：
- 先按出现的概率大小排队，把两个最小的概率相加，作为新的概率和剩余的概率重新排队
- 再把最小的两个概率相加，再重新排队
- 直到最后变成1。

>每次相加时都将“0”和“1”赋与相加的两个概率，读出时由该符号开始一直走到最后的“1”， 将路线上所遇到的“0”和“1”按最低位到最高位的顺序排好，就是该符号的赫夫曼编码。

## 哈夫曼算法（霍夫曼树）
典型的贪心算法，从概率最大的字符开始，一个接一个的添加字符。
将所有的节点放到一个队列中，用一个节点替换两个频率最低的节点，新的节点的频率就是这两个结点的评率之和。这样，新节点就是两个被替换节点的父节点了。如此循环，直到队列中只剩一个节点（树根）。
```py
from heapq import heapify,heappush,heappop
from itertools import count
def huffman(seq,frq):
    num = count()
    trees = list(zip(frq,num,seq))
    heapify(trees)
    while len(trees)>1:
        fa,_,a = heappop(trees)
        fb,_,b = heappop(trees)
        n = next(num)
        heappush(trees,(fa+fb,n,[a,b]))
    return trees[0][-1]
```
