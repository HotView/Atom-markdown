## 只有五行的Floyd-Warshall（弗洛伊德）
背景：需要求任意两个城市之间的最短路程，也就是任意两个点之间的最短路径。

这个问题也被称为“多源最短路径”问题，即求解任意两个点之间的最短路径。

怎样求解问题？之前的学习我们知道通过BFS，DFS求取两个点之间的最短路径。所以进行(N*N)遍深度或广度优先搜索，便可以求取任意两点之间的最短路径，但是这个算法太暴力，有没有其他的算法？

根据以往经验，如果想让任意两点之间的距离变短，只能引入第三点（顶点k），并通过这个顶点k，即a-->k-->b，才可能缩短从顶点a到顶点b的路径。

但是中转k是哪个点呢？甚至有时候不只通过一个点，而是经过两个或者多个点会更短。

当任意两点之间不允许经过第三点时，这些城市之间的最短路径就是初始路程。
- 假设先值允许经过1号点，求任意两点之间的最短路径，求解代码如下。
- 接下来继求经过1,2号两个顶点情况下任意两点之间的最短路程，即在经过1号更新之后的路程结果再应用经过2；号顶点
- 依次进行，直至到n号顶点，即允许经过1-n号所有顶点进行中转。
#### 假设只允许经过1号顶点的示例
这个算法是，只允许经过1号点的任意两点之间最短路径，如果小于两点直接的路径，就更新两点直接的路径，反之，不更新距离。
e[i][1]+e[1][j]表示从i号顶点先到1号顶点，再从1号顶点到j号顶点的路程之和。
更新所有点与点之间的距离。
```c
for (i = 1;i<=n;i++)
{
  for(j=1;j<=n;j++)
  {
    if(e[i][j]>e[i][1]+e[1][j])
      e[i][j] = e[i][1]+e[1][j];
  }
}
```
#### 核心算法
核心代码的基本思想就是：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号进行中转...允许经过1-n号所有顶点进行中转，求任意两点之间的最短路径。
用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。其实是一种“动态规划的思想”。
```c
for (k = 1;k<=n;k++)
  for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
      if(e[i][j]>e[i][k]+e[k][j])
        e[i][j] = e[i][k]+e[k][j]
```
