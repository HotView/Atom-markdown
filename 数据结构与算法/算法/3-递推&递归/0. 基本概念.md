当一个方法调用自身时，产生递归；或者A调用B，B调用A（或者说函数的调用出现回路）。

==递推从前往后，符合人的思维，递归从后往前，符合计算机！==
## 递归的概念
人类的总结：
- 递归就是有去（递去）有回（归来）
>我试图把我理解到递归思想用递归用程序表达出来，确定了三个要素：递 + 结束条件 + 归。

>但是，我很容易发现这样描述遗漏了我经常会遇到的一种递归情况，比如递归遍历的二叉树的先序。我将这种情况用如下递归程序表达出来。

>**“递”是必需，“归”并非必需，依赖于要解决的问题，有的需要去的路上解决，有的需要回来的路上解决**。有递无归的递归其实就是我们很容易理解的一种==分治思想==。

-  递归没有归
>其实理解递归可能没有“归”，只有去（分治）的情况后，我们应该想到递归也许可以既不需要在“去”的路上解决问题，也不需要在“归”的路上解决问题，只需在路的尽头解决问题，即在满足停止条件时解决问题。

## 递归的作用
- 代替多重循环
- 解决本来就是用递归形式定义的问题
- ==将问题分解为规模更小的子问题进行求解==
## 递归的应用
#### 第一类
问题的定义是按递归定义的
- 菲波那切数列
- 阶乘
- 杨辉三角
- 回文字符串
- 全排列
- 二分查找
#### 第二类
问题解法按递归算法实现
- 汉诺塔
- 爬楼梯
- 组合m苹果放n盘子问题
#### 第三类
数据的结构是按递归定义的
- 树：因为一棵树是自然递归的，构建，绘制和搜索树通常也是递归的。
## 递归与递推的关系
两者是可以进行相互转化的
- 递归是从大问题出发，分解大问题为小问题，然后小问题一次求解，最后得出大问题。
- 递推是小问题出发，由小问题逐步求解相比较大一点的问题。
## 堆栈空间
电脑为程序分配两方面的内存：栈和堆
- 栈存储方法调用的信息，当递归调用很深的深度并用尽栈空间时，使得程序崩溃。
- 堆，创建变量和完成计算。
## 特点
不需要额外的存储空间，因为它们使用树结构来跟踪它们在遍历中的位置。

如果递归的深度很深，可能导致栈溢出（这时可以考虑广度优先搜索进行）
## 几个递归的性质
序号|递归式|解决方案|应用实例
--|---|---|---
1|T(n) = T(n-1)+1  |O(n)   |序列化处理问题，归简操作  
2|T(n) = t(n-1)+n  |O(n2)   |握手问题  
3|T(n) = 2T(n-1)+1  |O(2^n)   |汉诺塔问题  
4|T(n) = 2T(n-1)+n  |O(2^n)   |
5|T(n) = T(n/2)+1  |O(logn)   |  二分搜索问题
6|T(n) = T(n/2)+n  |O(n)   |  随机选择问题，平均情况
7|T(n) = 2T(n/2)+1  |O(n)   |  树的遍历问题
8|T(n) = 2T(n/2)+n  |O(nlogn)   |利用分治进行排序问题  
- 式5的操作是单条路径上节点的计数问题
- 式6的操作求和是某一个二叉树的全部节点数，而$n/2^k$等于高度为k上的节点数（高度计算是从叶子节点开始，叶子结点的高度记为1），这就意味着该和值应该等于其节点数O(n)。
- 式7是各个节点边都要跟踪，所以就等同于节点计数问题，或者说O(n)级问题。



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU0NDQ2ODM1NiwyMDMzMzYyOTc3LDE5Mj
E2OTI3NDgsMzk5ODgwNTkwXX0=
-->
