当一个方法调用自身时，产生递归；或者A调用B，B调用A（或者说函数的调用出现回路）。
## 递归的概念
指在函数的定义中使用函数自身的方法。

定义好函数的输入输出，功能；然后逻辑实现主要考虑最外层与第二层的关系。
```py
if 问题足够简单：
	直接解决问题
	返回解
else：
	将问题分解为与原问题同构的一个或更多个更小的问题
	逐个解决这些更小的问题
def fib(n):
	if n==1 or n== 2:
		return 1
	else:
		return fib(n-1)+fib(n-2)
```


==递归本身就是有去(递)有回(归)的，所以可以搭配回溯算法来记录解的路径==

三个关键点
- 怎么将大问题划分为子问题
- 怎么将小问题的解组合为大问题的解
- 应该有一个条件能导致函数或者方法直接返回而不再继续递归调用。
## 作用特点
递归的作用
- 代替多重循环
- 解决本来就是用递归形式定义的问题
- ==将问题分解为规模更小的子问题进行求解==

不需要额外的存储空间，因为它们使用树结构来跟踪它们在遍历中的位置。
如果递归的深度很深，可能导致栈溢出（这时可以考虑广度优先搜索进行）
## 递归与递推的关系
==递推从前往后，符合人的思维，递归从后往前，符合计算机！==
两者是可以进行相互转化的
- 递归是从大问题出发，分解大问题为小问题，然后小问题一次求解，最后得出大问题。
- 递推是小问题出发，由小问题逐步求解相比较大一点的问题。
## 几个递归的性质
序号|递归式|解决方案|应用实例
--|---|---|---
1|T(n) = T(n-1)+1  |O(n)   |序列化处理问题，归简操作  
2|T(n) = t(n-1)+n  |O(n2)   |握手问题  
3|T(n) = 2T(n-1)+1  |O(2^n)   |汉诺塔问题  
4|T(n) = 2T(n-1)+n  |O(2^n)   |
5|T(n) = T(n/2)+1  |O(logn)   |  二分搜索问题
6|T(n) = T(n/2)+n  |O(n)   |  随机选择问题，平均情况
7|T(n) = 2T(n/2)+1  |O(n)   |  树的遍历问题
8|T(n) = 2T(n/2)+n  |O(nlogn)   |利用分治进行排序问题  
- 式5的操作是单条路径上节点的计数问题
- 式6的操作求和是某一个二叉树的全部节点数，而$n/2^k$等于高度为k上的节点数（高度计算是从叶子节点开始，叶子结点的高度记为1），这就意味着该和值应该等于其节点数O(n)。
- 式7是各个节点边都要跟踪，所以就等同于节点计数问题，或者说O(n)级问题。

## 题外话：堆栈空间
电脑为程序分配两方面的内存：栈和堆
- 栈存储方法调用的信息，当递归调用很深的深度并用尽栈空间时，使得程序崩溃。
- 堆，创建变量和完成计算。

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU0NDQ2ODM1NiwyMDMzMzYyOTc3LDE5Mj
E2OTI3NDgsMzk5ODgwNTkwXX0=
-->
