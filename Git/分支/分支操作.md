## 分支简介
git保存不是文件之间的变化和差异，而是一系列不同时刻的文件快照。

在进行提交操作时，Git会保存一个提交对象。该提交对象会包含一个指向暂存内容快照的指针。

我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件，暂存操作会为每个文件计算校验和，然后会把当前版本的文件快照保存到Git仓库中（Git使用bolb对象来保存它们），最终将校验和加入暂存区等待提交。

当使用git commit进行提交时，git会先计算每个子目录的校验和，然后将这些校验和保存为树对象。随后，Git创建一个提交对象，他除了包含上述信息之外，还包含指向这个树对象的指针。

现在Git仓库中有五个对象：三个bolb对象（文件快照），一个树对象（记录着目录结构和bolb索引）以及一个提交对象（包含指向前述树对象的指针和所有者的提交信息）
## 分支创建
Git是怎么创建分支的呢？很简单，他只是为你创建了一个可以移动的指针。HEAD指向当前分支。
## 分支分叉
你先创建一个新的分支，并在这个新的基础上做了一些更改，那么分支就会向前移动。之后，你切回master分支，也做了一些更改，那么这时分支就会分叉了。上述两次改动针对的是不同的分支。

你可来回切换两个分支工作，等到时机成熟之后，就把两个分支进行合并！
## 查看远程分支
- git branch -a
- git branch
- ==查看分支的提交历史，合并，以及项目分叉情况==
`git log --oneline --decorate --graph --all`
## 创建分支
- git branch test
## 切换分支
当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。
Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。
- git branch
- git checkout test(改变工作区的文件，its OK！)
## 合并分支
- ==类型一，两个合并的分支没有分叉，在一条分支上==
这时，是不会出现合并冲突的。
由于当前 master 分支所指向的提交是你当前  提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个  分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推  
进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “==快进（fast-forward）==”。

- ==当两个分支处于分叉的时候==
是有可能出现合并冲突的。
`$ git checkout master  `  
`$ git merge iss53`
出现这种情况时，Git会使用连个分支的吗，末端所指的快照（C4和C5）以及这两个分支共同的工作祖先（C2），做一个简单的三方合并。

## 遇到冲突时的合并
如果在两个分支中，对同一个文件的同一个部分进行了不同的修改，Git就没办法干净的合并它们。

你可以在合并期间使用git status命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。

任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件（当前分支中）中加入标准的冲突解决标记（如果是文件的话，就会包含三个文件，一个local，一个remote，一个base的三个文件），这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：  
```
<<<<<<< HEAD:index.html  
<div id="footer">contact : email.support@github.com</div>  
=======  
<div id="footer">  
please contact us at support@github.com  
</div>  
>>>>>>> iss53:index.html  
```
这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出  
到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，你必须选择使用由 =======  分割的两部分中的一个，或者你也可以自行合并这些内容。
你可以通过把这段内容换成下面的样子来解  
决冲突：  
```
<div id="footer">  
please contact us at email.support@github.com  
</div>
```  
上述的冲突解决方案仅保留了其中一个分支的修改，并且 <<<<<<< , ======= , 和 >>>>>>> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。
#### 另一个选择是使用图形化工具来实现这个操作，git mergetool来进行操作，这个针对文本文件比较合适。
## 删除远程分支
- git branch -d hotfix
- git branch -r -d origin/branch-name



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg0MjE1Mjc5MCwtMjYwMzMxNjIxLC0xNj
I1Njc5MjA1XX0=
-->