## 为什么需要进程间通信
Linux文件加锁一节可以看到，通过创建一个文件并使用适当的VFS系统调用对该文件加锁和解锁就可以在用户进程之间实现某种同步。
通过把数据存放在使用锁保护的临时文件中就可以实现用户态进程之间实现数据共享，然而这种方式的代价特别高，因为需要访问磁盘文件。

出于这个原因，所有的Unix内核都包含了一组系统调用，这些系统调用不用与文件系统打交道就可以支持进程通信；而且，已经开发了几个封装函数并将其加入到适当的库来加速进程对内核发出同步请求。
## Unix的进程通信机制
Unix提供的进程间通信的基本机制
- 管道
有些进程向管道中写入数据，而另外一些进程则从管道中读出数据。
- FIFO：
虽然管道简单灵活，有效，但是主要缺点无法打开已经存在的管道。除非管道由一个共同的祖先创建，否则任意两个进程不可能共享同一个管道。
- 消息
允许进程在预定义的消息队列中读和写消息来交换消息。
- 内存共享区
允许进程通过共享内存块来交换信息。在必须共享大量数据的应用中，这可能是最高校的进程通信形式。
- 套接字
允许不同计算机上的进程通过网络交换数据。套接字还可以作用相同主机上的进程之间的通信工具；
## 管道
管道可以看做是打开的文件，但在已安装的文件系统中没有相应的映像。可以使用pipe（）系统调用来创建一个新管道，这个系统调用返回一对文件描述符；然后通过fork（）把这两个文件描述符传递给它的子进程，由此子进程共享管道。
进程可以在read（）系统调用中使用第一个文件描述符从管道读取数据，同样可以使用write（）系统调用中使用第二个文件描述符向管道中写入数据。

管道是Unix都愿意提供的一种进程间通信机制。管道是进程之间的一个单向数据流：一个进程写入管道的所有数据都由内核定向到另一个进程，另一个进程由此就可以从管道中读出数据。
Linux中用  “|”来创建管道。
`$ ls | more`
第一个进程（执行ls程序）的标准输出被重定向到管道中；第二个进程（执行more程序）从这个管道中读取输入。
`ls > temp `
`more < temp`
这两句话和上面的效果是一样的，只是由一个文件来当媒介。
## FIFO
管道简单灵活，有效；但是主要缺点就是无法打开已经存在的管道，只能通过fork子进程去获得对管道的操作权。
由此引出了一个命名管道（FIFO：先进先出，最先写入管道的字节总是先被读出的特殊文件类型，不拥有磁盘块，与内核缓冲区相关联，缓冲区存放两个或多个进程之间交换的数据）

服务器和客户端的例子可以很容易的使用FIFO而不是管道。服务器在创立时，创建一个FIFO，由客户端程序用来发出自己的请求。
## IPC
IPC是进程间通信，通常指用户态进程执行一系列操作：
	1. 通过信号量与其他进程进行同步
	2. 向其他进程发送消息或者从其他进程接收消息
	3.	和其他进程共享一段内存区
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2MTM3MjQ2NjAsLTY1MTk2MDI0MiwxMD
c3MTAzNTBdfQ==
-->