背景：
村子修路，每两个村落都可以修路，做成一个连通图，花费最小，权重最小。
## 最小生成树
- 是一颗树：无回路。
- 生成树：包含全部顶点。
 -最小：边的权重和最小。

解决算法：都可以归结为==贪心算法==，解决问题是一步一步解决的，每一步都要最好的，只要眼前最好的。

约束：
- 只能用图里面的边
- 正好用掉|V|-1边
- 不能有回路

## prim算法、
有点像Dijkstra算法。适合稠密树。
对象是结点。
- 两个集合，已经收进来的（生成树），和没有收进来的。
- 每次选取距离生成树相关最短的没有收进来的边。
- 定义一个parent，存储生成树。/*parent【W】 = V*/
```c
void prim()
{
//没有连接的点距离设置为正无穷dist[V] = E<s,v>或正无穷。
	MST  = {s};
	while(1)
	{
		V = 未收录顶点中dist最小的；
		if（这样的V不存在）
			break；
		将V收录进MST；
		for(V的每个邻接点W)
			if(W未被收录)
				if（E<v,w><dist[W]）
				{
					dist[W] = E<v,w>;
					parent[W] = V;
				}
	}
		
}
```
## Kruskal算法
对象是边。适合稀疏树。
边集合：在图中每个最小的边收进来（不能构成回路）。
找到|v|-1个边，结束，证明已经找到了最小生成树了。
```c
void kruskal(graph G)
{
	MST = {};
	while(MST 中不到|V|-1边 && E中还有边)
	{	
		从E中去权重最小的边E<v,w>;/*最小堆*/
		将E<v,w>从E中删除；
		if（E<v,w>不在MST中构成回路）/*并查集*/
			将E<v,w>加入MST；
		else
			彻底无视E<v,w>；
	}
	if(MST中不到|V|-1条边)
		Error（“生成树不存在”）
	
```
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1MDM4MTY2Nl19
-->