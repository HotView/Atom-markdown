之前的介绍中，我们知道树的意义。
一些算法如树的遍历，其运行时间取决于树的总体大小。
其他的算法如插入新结点，其运行时间取决于树的高度；需要O(log N)。
当节点按排序顺序添加到树时，树会增高并变窄，故此时添加一个新节点需要O(N)的时间，可见后一种方法需要时间更长。

平衡树在需要时会重新排布自己的节点以使得树不会变得过高和过窄。
这些树可能没有达到完美平衡，树的平衡性会使得遍历它们的算法的时间复杂度缩小到O(log N)
## 类别
- AVL树：
左右分支平衡
- 2-3树：
内部节点都有两个或三个孩子
- B树
每一内部节点都存有一个或者两个值，并且具有两个或者三个分支。

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzcxMjc0ODQ0XX0=
-->