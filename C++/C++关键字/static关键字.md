==主要为了解决局部对象的生命周期的问题，加static之后的变量存储在，静态存储区，只有当函数结束时，这部分内存才会被释放，否则一致存在。==
如果声明一个静态的容器，那么这个容器内的每个元素只会被初始化一次，以后的每次，都只是被调用，类似有记忆类型的递归。
## 静态变量
背景：在所有的函数中，函数体在每次执行之后都不会保留任何信息。假定要计算某个函数的调用次数，该怎么办？一种方法是在文件作用域中定义一个变量，在函数中递增它。但是这个方法有一个潜在的问题：文件中任何函数都可以修改它，这样就不能按照希望的递增。
较好的解决方案是：在函数体中把该变量定义为static，则它的作用域只会在函数中。但是每次函数执行完之后，不会释放这个值的资源。
## 面向对象的关键字
#### 静态成员变量
- ==生命周期不同==
成员变量（实例变量）：对象存在，变量才存在。存在堆中。
静态变量：类变量，类可以直接访问的变量。随着类的加载而存在，随着类的消失而消失。

- 数据存储位置

==静态成员提供了一个同类对象的共享机制（节省内存空间，对于拥有相同数据的对象而言。）==
声明的属性变量是所有对象共享的，所有对象指向同一个属性。是属于整个类的。
成员变量存储在堆内存的数据中，也叫对象的特有数据java。（堆里面只能放实体，数据放在实体中）
静态变量存储在静态存储区（数据段）

- 调用不同
静态变量调用可以通过对象调用：==对象名.属性==。也可以用“类名::”做限定词。
成员变量只能用对象调用。


#### 静态成员函数
声明的成员函数是所有对象共享的。是属于整个类的，可以用类名直接调用。
- 带有关键字static
- 静态成员函数提供不依赖于类数据结构的共同操作，他没有this指针。
- 在类外调用静态成员函数，用“类名::”作为限定词，或通过对象调用。
- 可以使用静态成员变量，==不能使用普通变量（非静态）==。因为普通变量是属于某一个确定对象的。而静态成员函数是属于整个类的，两者调用有矛盾，没办法理清从属关系，调用的普通变量到底是谁的普通变量？
#### 静态代码块
装载时就会执行，主要是初始化值。
## C语言中的static
源文件中的内部函数，不能在其他文件中调用。
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc5NjgxMTQ1NF19
-->
