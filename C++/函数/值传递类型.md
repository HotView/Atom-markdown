## 简介
- 值传递：值传递仅传递了实参的拷贝，在传参时会在栈区开辟内存空间并将实参值拷贝其中。
- 引用传递：引用传递实际上是为了实参设置了别名（==相当于把变量和值都传递进去了==），其在栈区开辟内存空间后并不进行拷贝，而是存放实参的地址，从而对形参的操作实际上是通过对实参的简介寻址来实现，==相当于直接在函数外操作实参一样。==
- 指针传递：指针传递其实是特殊的值传递，区别是其传递的值时地址而值传递是传递了实参的值。指针传递时会在栈区开辟内存空间并存放指针，而指针指向实参的地址。
## 引用的定义
被调函数对形参做任何操作都会影响主调函数的值。
```c
void change(int &n,int &m)
{
	int temp;
	temp = n
	n = m;
	m = temp;
}
```
## 指针与引用的区别
两种方式只是一个语法糖，其编译后的结果是一样的，所以只是个人的写程序的表达方式不同。
- 是否为空
引用必须对应一个有效的内存地址，因为其本质是实参的别名，而指针可以指向一个空地址，因为其本质上是可以指向某地址的指针。
- 是否是实体
指针实际上也是一种类型，其指向一个内存地址，其与目标变量之间并无关系。而引用实际上是作为变量别名来存在，并非一个独立的实体
>在使用时，引用不能改变其引用地址，只能改变目标变量的值，而指针可以改变地址和被指向变量的值，这一点显示了后者是一个独立的实体。

- sizeof 
 我们知道sizeof用来计算变量大小，当我们对引用取sizeof时，得到的是其引用变量的大小，而对指针使用sizeof，得到的只是指针变量的大小，与被指向变量无关。
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwNjk5ODE5MDldfQ==
-->