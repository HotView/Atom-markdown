编译器用函数的签名来区分函数，函数的签名是函数名及其参数列表的组合。
重载的函数名字相同，所以每个重载函数的签名必须有不同的参数列表。
- 函数的参数个数不同。
- 至少有一对对应参数的类型不同。
## 函数的重载
我们常常用两个或多个函数完成相同的任务，但是其参数的类型不同。
#### 3. 重载和const
const参数与非const参数的唯一区别就是为引用定义参数，还是为指针定义参数。
对于基本类型const int和int是相同的。

- 重载和const指针参数
如果在两个重载函数中，一个函数的参数类型是type*，而另一个函数的参数类型是const type*，这两个函数就是不同的
- 重载和const引用参数
类型T&和constT&总是不同的，所以类型const int&总是与类型int&不同。
## 函数的返回值
#### 1. 返回指针
返回指针时，它必须包含bullptr，或者调用函数中仍旧有效的地址。==不要从函数中返回自动局部变量的地址==
```c
int * larger(int a,intb)
{
if (a>b)
	return &a;
else
	return &b;
}
```
上述例子就是错误的，因为a，b只是拷贝过来的值，是函数局部变量。

正确的做法是：
```c
int * larger(int * a,int * b)
{
	if (*a>*b)
		return a;
	else
	return b;
}
```
#### 2. 返回引用

## 给函数传送参数
#### 3. const指针参数
背景：有些函数只需访问数组元素的值，不需要修改它们。最好确保函数中代码不会在无意中修改此数组元素，这需要把参数类型设置为const。

指定参数指针为const，有两个结果：编译器检查函数体中的代码，确保不会试图修改指针所指向的值；他还允许指向一个常量的实参来调用函数。
>把基本类型（如int或者sie_t）的参数是没有意义的。因为按照值传递机制会在调用函数时复制变元，所以不能在函数中修改变元原来的值。




> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1MzY3NzQ2MjldfQ==
-->
