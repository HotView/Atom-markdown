## 继承关系
- 基类在内部，派生类在外部
- 构造由内而外，先调用Base的构造函数，然后再执行自己
- 析构由外而内，先执行自己，再调用Base的析构函数
## 复合关系
- 我拥有你，你就是内部，我就外部。
- 构造由内而外，先调用component的构造函数，然后再执行自己。
- 析构由外而外
## 继承+组合
- 基类是在最内部，component次之，我在最外部
- 构造由内而外：首先调用Base的构造函数，然后调用Component的构造函数，然后再执行自己。
- 析构就是构造的逆序。
## vptr和vtbl
虚指针和虚表
- 当一个类有一个虚函数，对象里就会多一个虚指针
- 虚指针指向虚表
- 虚表里存放的是虚函数的指针，分别指向虚函数。

派生类的虚指针与父类的虚指针不同，分别指向不同的虚表，虚表里存放的是虚函数的指针，如果派生类覆盖了虚函数，那么覆盖了虚函数的指针在派生类中要被修改，没有覆盖的虚函数的指针，与父类的保持一致。

==动态绑定的流程：通过对象的指针，找到虚指针vptr，通过vptr找到vtbl，再从表里看指针指向哪里。==
虚机制
- `(*(p->vptr)[n])(p)`：n表示表中的第几个指针。
- `(* p->vptr[n])(p)`
## 虚函数
- 对于以后可能需要变化的函数定义为虚函数
- 将来通过基类指针调用时，就可以根据实际的指向的对象，来调用派生类的虚函数还是基类的虚函数。

虚函数，多态，动态绑定讲的是同一件事情。
## 静态绑定和动态绑定
语法形式：
`call ...`

动态绑定三要素：
- 指针调用
- 指针向上转型：类型是基类，但是new的时候是派生类对象
- 调用的是虚函数
## 与容器的关系
当容器包含不同的类型的对象时，可以在容器里放指针，通过指针调用不同的对象类型
- 前提条件，这些不同类型的对象有共同的基类
- 容器里存放基类的指针
- list<A*> myLst
- A<----B<----C<-----D
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQ3MzQxNTk0NSwtMTkyMTMwMzk4NSw0Mj
E2NDgwNjEsMTI1MTU5MDI4Miw3NDE4MDAyNjRdfQ==
-->