## 使用场景和背景
使用场景：==一般用在参数传递中！==

背景：防止拷贝，加快速度，减小内存的使用量。
类的设计者考虑的问题，传入参数时，考虑传入的参数要不要改变，不改变的话就传const，修改的话就不加const，为了速度和内存空间，尽量使用引用。

传出返回值时，考虑得到的对象，是函数内新创建的，还是函数外已有的。
- 如果是新创建的，那就不加引用，直接值返回；
- 如果不是新创建的（local object），尽量使用引用返回。
##  引用传送
==相当于直接在子函数中直接操作运算主函数中的变量，某种角度来说，扩展了主函数中的作用域。对于原变量可读可写（值传递：只读的）==

引用只是一个变量的别名。可以把函数指定为引用，此时，函数使用按引用机制来传送变元。
在调用函数时，对应于引用参数的变元不会复制。==内存占用较小==
引用参数通过变元初始化，因此它是调用变元的别名，只要在函数体中使用参数名，它就会==直接访问调用函数中的变元值==。
```c
//定义使用相同
void func2(Cls obj){...}
void func3(Cls& obj){...}
//调用接口相同
func2(obj);
func3(obj);
//签名相同,为了和接口保持一致！
double imag(const double& im){}
double imag(const double im){}
```
## 引用返回
默认情况下，当函数返回一个值，该值拷贝到临时存储空间，然后再拷贝到函数调用处，我们称此为传值返回。

在引用返回下，返回值不再拷贝到临时存储空间，直接拷贝到函数调用处，甚至连return语句所用的那个存储单元对调用者而言都是可访问的。引用返回的语法在返回类型前加一个符号&。


## 引用（代表）
>==传递的是原对象（原变量）的一个别名，只是底层操作实现是指针，但是是停留在变量阶段，和地址没有联系！==
>int& p = x;  p代表x！（对待p是用指针来实现的，逻辑上是代表！）

int* p = &x；取地址
int& r = x；引用
两者不相同。
**一定要有初值！自此不能再进行改变代表！但是其值是可以改变的**
```c
int x= ;
int& r = x;
int x2 = 5
r =x2;//r不能重新代表其他物体，现在r，x都是5
int& r2 =r//现在r2是5
```
有两种：左值引用，右值引用。
- 左值引用：是一个别名，所以在定义该引用时，它指向的变量必须存在。单个&
- 右值引用：可以是变量的别名，不同的是它还可以引用右值，即临时值。双&
## 引用和常引用
引用的话只能引用变量，不能引用表达式。
变量和普通引用都可以赋值给常引用，但是常引用不能赋值给引用。
int n =6;
const int& r = n

int n =8;
int& r1 = n;
const int& r2 = r1## 用引用
用的引用变量，引用。
变用引用，是用用。
i n 
ons& 

nn;
int&  const intr 
##  引用有风险的
引用函数支持在调用函数中修改变元，但调用包含引用参数的函数与调用包含按值传送变元的函数没有区别（==两者的函数形式是一样的==）。如果没有函数的源代码，就无法知道参数是否引用。

因此在不改变变元的函数中使用const尤为重要。
- const应用于变量，就告诉编译器，该变量是一个常量，不可修改。
- const应用于引用参数，就告诉编译器，函数不会修改变元，所以编译器要确保这一点。

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzE4ODEyOTc2LDEyNzMxOTU2ODMsLTE0Nj
Q1MjE3OTUsLTEwMzAwMDc5MTYsLTIzMzE3Mzg0OSwxMDQzNjA5
ODgwLDEzMDk0MjE2MDUsODMxMzA4OTIyXX0=
-->