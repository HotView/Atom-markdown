指针和引用的概念具有相似性，所以在一章中介绍他们。
指针非常重要，因为它是构成动态分配内存的基础。
==引用和指针是面向对象编程的基础==
#### 用法：p->
## 为什么使用指针？
==可以通过一个字节的变量，来访问很多位置的数据，高效，节省内存空间，便捷（尤其是参数值占用很大的内控时，值拷贝很浪费时间）。==
>指针：我的数据保存在一个固定的位置，我给你一个可以操作到我数据的地址。
- 可以使用指针记号操作存储在数组中的数据，这常常比使用数组表示法快一些
- 定义自己的函数时，可以在函数内访问在该函数外部定义的大块数据，例如数组。
- 可以动态的为新变量分配内存空间。在程序执行过程中分配。程序执行过程中需要创建新变量；分配新内存时，内存由其地址标识，所以需要指针来记录它。
- 指针是支持多态性起作用的基础，而多态性是面向对象编程的最重要的功能。
## 什么是指针
程序中每个变量和函数都位于内存中的某个地方，所以都有一个独特的地址来标识它们的位置。这些地址取决于运行程序时将程序加载到内存什么地方，所以程序每次运行时，这些地址可能都不同。

==指针是一个可以存储地址的变量。==

定义一个指针不一定要初始化它，但是最好初始化它。
```C++
long *pnumber {};//A poinnter to type long.
long *pnumber{nullptr}://c初始化为空的指针，不指向任何内容的地址。
```
###
## 空指针
nullptr是C++11语言标准用来表示空指针的常量值，可以指派给任意类型的指针变量。
在C语言中，空指针可以使用(void \*)0;来表示，且标准库中也是如此定义，但在C++语言中，由于对语法的类型检查更为严格，因而空指针的值就不能表示为(void \*)0;。例如，空指针的值表示为FILE \*fp=(void \*)0;编译报错。所以至少自C++98开始#define NULL 0。 但这会在函数重载时遇到新的困难。例如

void foo(char c, void *p);
void foo(char c, int i);
int main()
{
    foo('x',NULL);//匹配哪个版本的foo()？
}
C++11开始，定义了空指针的常值为nullptr，解决了上述函数重载问题。

## 地址运算符
地址运算符&是一个一元运算符，它可以获取变量的地址。
下面语句定义了一个指针pnumber和一个变量numbe，pnumber用number的地址初始化：
```
long number {12345L}:
long* pnumber {&number}
```


## 总结
- 指针越少出现越好。
- 能用引用就用引用，因为引用相对比较安全。
- 能将指针包装起来就包装起来，如智能指针，目的就是防止内存泄漏。
- 内存泄漏，大家都知道指针是罪魁祸首，那如果我们现在在代码级别都看不到多少指针，出错的概率就会很低了。
- 像C，C++语言没有绝对的安全可言的，我们能做的就是提高安全级别。

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgzNzgxMjMzOSwtMTAxMTAwMDQxMSwtOD
c4OTYyNzMsMzk3OTQ4MTU5LDEyNDU2ODc2NTFdfQ==
-->