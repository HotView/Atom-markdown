标准库主要有两种组件构成：一是容器，包括vector，list，map等；另一种是以操作这些容器的所谓的算法，包括find，sort，replace，merge等。

泛型算法之所以被称为泛型，是因为它们和它们想要操作的元素类型无关，它们同样也和容器类型无关（不论是vector，list，或array等）

STL是以泛化原则为基础的：
- 数组被泛化为“以其包含的对象的类型为参数”的容器
- 函数被泛化为“以其使用的迭代器的类型为参数”的算法
- 指针被泛化为“以其指向的对象类型为参数”的迭代器
## STL的优越性
和C++数组不同，STL容器的大小自动变化。
当插入新元素时，STL容器自动增大，删除元素时，自动减小。
除了容器之外，STL还提供了大量用来处理容器的算法，如排序，搜索，替换，倒置，分割和测试等等
## 整体结构
六大部件
- 容器
- 分配器(Allocators)
- 适配器
- 迭代器(Iterators)
- 算法(Algorithms)
- 仿函式（Functors）

==分配器：==分配内存空间给容器使用,回收内存等操作，分配器把内存的问题全部解决了！
容器和算法是分离的，桥梁是迭代器！
算法通过迭代器访问容器！
仿函数协助算法完成不同的策略变化！
适配器嵌套仿函数。
==上述的联系的编程思想与面向对象的思想不同。==
## C++标准库和标准模板库
C++标准库是新式叫法，后者是旧式叫法。
- 新式的头文件不带.h，也支持带.h的头文件。
- \*(v.end()):危险动作，未知结果。
- 新式的头文件封装于namespace std
## 标准库区间标准
前闭后开
- begin指向第一个元素，end指向最后一个元素的下一个位置。
- 所有的容器遵守这个规则



## 函数对象
在C++中可以像对待其他运算符一样对待函数调用运算符();这个运算符有可以重载。()运算符能够返回任何类型，可以使用任何数量的参数，但和赋值运算符一样，该运算符只能重载为成员函数。
- 包含函数调用运算符定义的对象称为函数对象，函数对象也是对象，只是行为表现的更像函数。
- STL特别依赖函数对象。函数指针机制对于内置的运算符是不够的。例如如何将负号赋给sum？为了解决这个问题，STL在<functional>中为常见的C++==运算符==定义了==函数对象==
```c
template <class T>
struct negate:public unary_function<T,T>
{
    T operator()(const T &x)const
    {
        return -x;
    }
}
```
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY2MjU3Mzk0NCw4NzkzNjI4ODksLTEzMj
EyMTY0NzQsMTIzMTkyODMwM119
-->
