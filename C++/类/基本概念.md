定义一个类就定义了一个新的==数据类型==。

面向对象编程（OOP）本质是，根据要解决的问题范围内所涉及的对象来编写程序，因此程序开发过程的一部分就是设计一组类型来满足这个需求。

==类类型可以组合其他类型的变量——基本类型或者其他类类型==
==类还可以把函数作为其定义的一个组合成分==
## 结构和类
按照定义，一个struct也就是一个类，但是其成员默认是公用的；也就是说，
`struct s {.....};`只是下面定义的简写
`calss s{public:.....};`
- 可以使用访问描述符private：说明紧随其后的是一些私有的成员，采用哪种形式看自己的偏好。
## 封装性
## 继承性
==使我们得以将一群相关的类组织起来==
- 让我们得以分享其间的共通数据和操作行为
- 代码复用
## 多态性
==让我们在继承性质的基础上进行编程时，即有共同父类的派生类上编程时，可以如同操作单一个体，而非相互独立的类==
- 并赋予我们更多的弹性来加入或移除任何特定类。


多态的**对象**主要是使用**基类的指针**来访问派生类的成员函数。
>多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，==父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。==简单的说：允许将子类类型的指针赋值给父类类型的指针（一个接口，多种方法）。  
C++ 支持两种多态性：编译时多态性，运行时多态性。  
a、编译时多态性（静态多态）：通过重载函数实现  
b、运行时多态性（动态多态）：通过虚函数实现。
>>多态表现为同样的调用语句，有多种不同的调用方式
例如：80年代的人写的框架，90年代的框架什么都不需要变，只需要根据业务需要继承以前的父类，重写父类以前的方法，将子类对象指针（或引用）传入框架即可。

#### 背景
我们直观上认为，如果指针指向了派生类对象，那么就应该使用派生类的成员变量和成员函数，这符合人们的思维习惯；  
但是本例的运行结果却告诉我们，当基类指针 p 指向派生类 Student 的对象时，虽然使用了 Student 的成员变量，但是却没有使用它的成员函数，导致输出结果不伦不类，不符合我们的预期；

换句话说，**通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数**；

为了消除这种尴尬，让基类指针能够访问派生类的成员函数，C++ 增加了`虚函数（Virtual Function）`；使用虚函数非常简单，只需要在函数声明前面增加`virtual`关键字；

有了`虚函数`，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员；  
换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为`多态（Polymorphism）`；

 #### 作用
 那么多态的作用是什么呢，封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了**接口重用**。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。
 #### 多态成立的条件
 - 要有继承
 - 要有函数重写
 - 要有父类指针指向子类对象。
> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwOTgzODEzMiwtMzY0MzIyMzI4LC00Mz
Y4OTU2MCwtNzUzOTUzMTA5LDE1MTEyODQ5MzYsLTcyMzYyOTQ3
MCwtOTI4MjcwOTg0LC00MDk2ODczMzYsMjAwMDc5Njc2OV19
-->
