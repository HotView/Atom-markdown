时间复杂度为O（N*log N）
## 堆排序
可以使用一个简单的公式将堆存储在数组中。
- 首先根节点放置于下标为0的位置。
- 之后对于任何下标为i的节点，将它的子节点放置于2*i+1,2*i+2的位置
- 如果一个节点的下标为j，父节点下标为 (j-1)/2

#### 堆的性质
- 最底层的所有节点放在左侧
- 节点的值都大于或等于其子节点的值。 
#### 定义堆
建立堆时间复杂度为O（N*log N）
- 从一颗仅包含一个节点的树开始一次一个节点的建立堆。
- 因为它没有子节点，因此满足堆的性质
- 为它添加一个新的节点。如果将节点加入树的末端，只能在一个位置-最底层的最右端，添加这个位置才能保证这是一棵完全二叉树。
- 将节点值与父节点比较。如果新节点值大的话，将其交换。
- 然而更改父节点的值，有可能打破更高层堆的性质，继续向上比较其父节点并在必要时交换它们
- 以上的复杂度为O(log N)
#### 堆排序
为了完成排序，算法将每一个元素从堆中删除并维护堆的性质。
方法是交换第一个和最后一个元素，并将根节点的新元素不断向下移动直到满足堆的性质，时间复杂度为O(log N)。算法重复需要执行N次，排序的总时间复杂度为O（N*log N）
- 算法建立一个堆，
- 不断的交换第一个和最后一个元素
- 将最末端的元素移除后并加入排好序的数组末端
- 重复上述步骤，维护堆的性质
## 快速排序
## 归并排序
 


> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU2ODg2NDM3OF19
-->