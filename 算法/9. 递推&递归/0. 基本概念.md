当一个方法调用自身时，产生递归；或者A调用B，B调用A（或者说函数的调用出现回路）。

==递推从前往后，符合人的思维，递归从后往前，符合计算机！==
## 递归的概念
人类的总结：
- 递归就是有去（递去）有回（归来）
>我试图把我理解到递归思想用递归用程序表达出来，确定了三个要素：递 + 结束条件 + 归。

>但是，我很容易发现这样描述遗漏了我经常会遇到的一种递归情况，比如递归遍历的二叉树的先序。我将这种情况用如下递归程序表达出来。

>**“递”是必需，“归”并非必需，依赖于要解决的问题，有的需要去的路上解决，有的需要回来的路上解决**。有递无归的递归其实就是我们很容易理解的一种==分治思想==。

-  递归没有归
>其实理解递归可能没有“归”，只有去（分治）的情况后，我们应该想到递归也许可以既不需要在“去”的路上解决问题，也不需要在“归”的路上解决问题，只需在路的尽头解决问题，即在满足停止条件时解决问题。
## 递归的作用
- 代替多重循环
- 解决本来就是用递归形式定义的问题
- ==将问题分解为规模更小的子问题进行求解==
## 递归的应用
#### 第一类
问题的定义是按递归定义的
- 菲波那切数列
- 阶乘
- 杨辉三角
- 回文字符串
- 全排列
- 二分查找
#### 第二类
问题解法按递归算法实现
- 汉诺塔
- 爬楼梯
- 组合m苹果放n盘子问题
#### 第三类
数据的结构是按递归定义的
- 树：因为一棵树是自然递归的，构建，绘制和搜索树通常也是递归的。
## 递归与递推的关系
两者是可以进行相互转化的
- 递归是从大问题出发，分解大问题为小问题，然后小问题一次求解，最后得出大问题。
- 递推是小问题出发，由小问题逐步求解相比较大一点的问题。
## 堆栈空间
电脑为程序分配两方面的内存：栈和堆
- 栈存储方法调用的信息，当递归调用很深的深度并用尽栈空间时，使得程序崩溃。
- 堆，创建变量和完成计算。
## 特点
不需要额外的存储空间，因为它们使用树结构来跟踪它们在遍历中的位置。 

如果递归的深度很深，可能导致栈溢出（这时可以考虑广度优先搜索进行）



> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU0NDQ2ODM1NiwyMDMzMzYyOTc3LDE5Mj
E2OTI3NDgsMzk5ODgwNTkwXX0=
-->